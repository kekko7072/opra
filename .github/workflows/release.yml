name: Build and Release

on:
  push:
    branches:
      - main

permissions:
  contents: write
  
jobs:
  build-and-release:
    runs-on: macos-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable
    
    - name: Get version from project
      id: version
      run: |
        VERSION=$(xcodebuild -showBuildSettings -project macos/Opra.xcodeproj -target Opra | grep MARKETING_VERSION | head -1 | awk '{print $3}')
        if [ -z "$VERSION" ]; then
          VERSION="1.0.0"
        fi
        BUILD_NUMBER=$(xcodebuild -showBuildSettings -project macos/Opra.xcodeproj -target Opra | grep CURRENT_PROJECT_VERSION | head -1 | awk '{print $3}')
        if [ -z "$BUILD_NUMBER" ]; then
          BUILD_NUMBER="1"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION-build$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "Version: $VERSION (Build $BUILD_NUMBER)"
    
    - name: Import Code Signing Certificate
      env:
        CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
        CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
      run: |
        # Verify secrets are available
        if [ -z "$CERTIFICATE_BASE64" ]; then
          echo "Error: APPLE_CERTIFICATE_BASE64 secret is not set"
          exit 1
        fi
        
        if [ -z "$CERTIFICATE_PASSWORD" ]; then
          echo "Error: APPLE_CERTIFICATE_PASSWORD secret is not set"
          exit 1
        fi
        
        # Create temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        KEYCHAIN_PASSWORD=$(openssl rand -base64 32)
        
        echo "Creating keychain at: $KEYCHAIN_PATH"
        
        # Create keychain
        security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        
        # Decode certificate
        echo "Decoding certificate..."
        echo "$CERTIFICATE_BASE64" | base64 --decode > certificate.p12
        
        # Verify certificate file was created
        if [ ! -f certificate.p12 ]; then
          echo "Error: Failed to create certificate.p12 file"
          exit 1
        fi
        
        echo "Certificate file size: $(wc -c < certificate.p12) bytes"
        
        # Import certificate with -A flag to allow all applications
        echo "Importing certificate..."
        security import certificate.p12 \
          -k $KEYCHAIN_PATH \
          -P "$CERTIFICATE_PASSWORD" \
          -T /usr/bin/codesign \
          -T /usr/bin/productsign \
          -A
        
        # Set key partition list
        echo "Setting key partition list..."
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
        
        # Add keychain to search list
        echo "Adding keychain to search list..."
        security list-keychain -d user -s $KEYCHAIN_PATH login.keychain
        
        # Verify import
        echo "Verifying certificate import..."
        security find-identity -v -p codesigning $KEYCHAIN_PATH
        
        IDENTITY_COUNT=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep -c "valid identities found")
        if [ $IDENTITY_COUNT -eq 0 ]; then
          echo "Warning: No identities found after import"
        fi
        
        # Clean up certificate file
        rm certificate.p12
        
        echo "Certificate imported successfully"
    
    - name: Build app
      run: |
        xcodebuild -project macos/Opra.xcodeproj \
          -scheme Opra \
          -configuration Release \
          -derivedDataPath ./build \
          CODE_SIGN_IDENTITY="" \
          CODE_SIGNING_REQUIRED=NO \
          CODE_SIGN_ENTITLEMENTS="" \
          CODE_SIGNING_ALLOWED=NO \
          clean build
    
    - name: Verify build output
      run: |
        echo "Checking build output..."
        ls -la ./build/Build/Products/Release/
        if [ ! -d "./build/Build/Products/Release/Opra.app" ]; then
          echo "Error: Opra.app not found!"
          exit 1
        fi
        echo "Build successful!"
    
    - name: Code Sign Application
      run: |
        # Set keychain to use
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        
        echo "Listing available identities..."
        security find-identity -v -p codesigning $KEYCHAIN_PATH
        
        echo "Signing application..."
        # Find the Developer ID Application identity
        IDENTITY=$(security find-identity -v -p codesigning $KEYCHAIN_PATH | grep "Developer ID Application" | head -1 | grep -o '".*"' | tr -d '"')
        
        if [ -z "$IDENTITY" ]; then
          echo "Error: No Developer ID Application certificate found"
          exit 1
        fi
        
        echo "Using identity: $IDENTITY"
        
        codesign --force --deep --sign "$IDENTITY" \
          --options runtime \
          --timestamp \
          --keychain $KEYCHAIN_PATH \
          ./build/Build/Products/Release/Opra.app
        
        echo "Verifying signature..."
        codesign --verify --verbose ./build/Build/Products/Release/Opra.app
        codesign -dv --verbose=4 ./build/Build/Products/Release/Opra.app
        
        echo "Code signing completed successfully"
    
    - name: Create DMG
      run: |
        # Create a temporary directory for the DMG
        mkdir -p dmg_temp
        
        # Copy the app to the DMG directory
        cp -R ./build/Build/Products/Release/Opra.app dmg_temp/
        
        # Create a symbolic link to Applications
        ln -s /Applications dmg_temp/Applications
        
        # Create the DMG
        hdiutil create -volname "Opra ${{ steps.version.outputs.version }}" \
          -srcfolder dmg_temp \
          -ov -format UDZO \
          Opra-${{ steps.version.outputs.version }}.dmg
        
        # Clean up
        rm -rf dmg_temp
        
        echo "DMG created successfully"
        ls -lh Opra-${{ steps.version.outputs.version }}.dmg
    
    - name: Notarize DMG
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "Submitting DMG for notarization..."
        
        # Submit for notarization
        xcrun notarytool submit Opra-${{ steps.version.outputs.version }}.dmg \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_ID_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait
        
        echo "Notarization completed"
    
    - name: Staple DMG
      run: |
        echo "Stapling notarization ticket to DMG..."
        xcrun stapler staple Opra-${{ steps.version.outputs.version }}.dmg
        
        echo "Verifying staple..."
        xcrun stapler validate Opra-${{ steps.version.outputs.version }}.dmg
        
        echo "DMG stapled successfully"
    
    - name: Notarize and Create ZIP of app
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
      run: |
        echo "Creating ZIP for notarization..."
        cd ./build/Build/Products/Release/
        zip -r temp-app.zip Opra.app
        
        echo "Submitting app ZIP for notarization..."
        xcrun notarytool submit temp-app.zip \
          --apple-id "$APPLE_ID" \
          --password "$APPLE_ID_PASSWORD" \
          --team-id "$APPLE_TEAM_ID" \
          --wait
        
        echo "Stapling notarization ticket to app..."
        xcrun stapler staple Opra.app
        
        echo "Verifying staple..."
        xcrun stapler validate Opra.app
        
        echo "Creating final ZIP..."
        rm temp-app.zip
        zip -r $GITHUB_WORKSPACE/Opra-${{ steps.version.outputs.version }}.app.zip Opra.app
        
        cd $GITHUB_WORKSPACE
        echo "ZIP created successfully"
        ls -lh Opra-${{ steps.version.outputs.version }}.app.zip
    
    - name: Generate release notes
      id: release_notes
      run: |
        cat > release_notes.md << 'EOF'
        ## Opra v${{ steps.version.outputs.version }}
        
        ### ðŸš€ What's New
        
        Cross-platform PDF Reader AI with automated release built from the latest main branch commit.
        
        ### ðŸ“¦ Downloads
        
        #### macOS
        - **Opra-${{ steps.version.outputs.version }}.dmg**: macOS disk image (recommended)
        - **Opra-${{ steps.version.outputs.version }}.app.zip**: Standalone app bundle
        
        #### Windows
        - **opra-windows**: Windows executable (self-contained)
        
        ### ðŸ“ Installation
        
        #### macOS - Option 1: Using DMG (Recommended)
        1. Download the `.dmg` file
        2. Open the downloaded `.dmg` file
        3. Drag the Opra app icon to your Applications folder
        4. Launch Opra from your Applications folder
        
        #### macOS - Option 2: Using ZIP
        1. Download the `.app.zip` file
        2. Extract the ZIP file
        3. Move Opra.app to your Applications folder
        4. Launch Opra from your Applications folder
        
        #### Windows
        1. Download the `opra-windows` artifact
        2. Extract the files
        3. Run `Opra.exe`
        
        ### âœ… Security & Notarization
        
        #### macOS
        This app is **properly code-signed and notarized by Apple** using a Developer ID certificate. 
        
        You should be able to open it directly without any security warnings. The app has been verified by Apple's notarization service and is safe to run.
        
        If you encounter any security warnings (rare), you can:
        1. **Right-click** (or Control-click) on Opra.app and select **"Open"**
        2. Click **"Open"** in the dialog that appears
        
        #### Windows
        The Windows version is built with .NET 8.0 (LTS) and includes all necessary dependencies. No additional installation required.
        
        ### ðŸ“‹ Build Information
        
        - **Version**: ${{ steps.version.outputs.version }}
        - **Build**: ${{ steps.version.outputs.build }}
        - **Commit**: ${{ github.sha }}
        - **macOS Code Signing**: Developer ID Application
        - **macOS Notarization**: Apple Notary Service
        - **Built with**: Xcode on macOS (latest stable) + .NET 7.0 on Windows
        EOF
        
        echo "Release notes generated"
    
    - name: Create Release
      uses: ncipollo/release-action@v1
      with:
        tag: ${{ steps.version.outputs.tag }}
        name: "Opra v${{ steps.version.outputs.version }}"
        bodyFile: release_notes.md
        draft: false
        prerelease: false
        artifacts: |
          Opra-${{ steps.version.outputs.version }}.dmg
          Opra-${{ steps.version.outputs.version }}.app.zip
          opra-windows
        token: ${{ secrets.GITHUB_TOKEN }}
        allowUpdates: true
        artifactErrorsFailBuild: true
    
    - name: Cleanup
      if: always()
      run: |
        # Delete the temporary keychain
        if [ -f "$RUNNER_TEMP/app-signing.keychain-db" ]; then
          security delete-keychain $RUNNER_TEMP/app-signing.keychain-db || true
          echo "Temporary keychain deleted"
        fi

  build-windows:
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Install Windows App SDK workload
      run: |
        dotnet workload install maui-windows
    
    - name: Build Windows App
      run: |
        dotnet build windows/Opra.sln -c Release
    
    - name: Publish Windows App
      run: |
        dotnet publish windows/Opra/Opra.csproj -c Release -r win-x64 --self-contained true -p:PublishSingleFile=true -p:PublishReadyToRun=true -o windows-publish
    
    - name: Upload Windows App
      uses: actions/upload-artifact@v4
      with:
        name: opra-windows
        path: windows-publish/
        retention-days: 30
